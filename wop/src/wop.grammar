use crate::Sym::*;
use crate::Ast;

alias ";" Sc;
alias "::" PathAccess;
alias "=" Assign;
alias "alias" AliasWord;
alias "use" UseWord;
alias "*" Glob;
alias ":" TwoDots;

EntryPoint: Ast = Program -> { Ast::EntryPoint(Box::new(toks[0].clone())) }% ;

Program: Ast = Program Alias ";" -> { 
    let program = &toks[0];
    let extension = toks[1].clone();
    let mut program_vec = match program.item.item {
        Ast::Program(ref v) => v.clone(),
        _ => unreachable!(),
    };
    program_vec.push(extension);
    Ast::Program(program_vec)
}%
    |  Program Import ";" -> {
    let program = &toks[0];
    let extension = toks[1].clone();
    let mut program_vec = match program.item.item {
        Ast::Program(ref v) => v.clone(),
        _ => unreachable!(),
    };
    program_vec.push(extension);
    Ast::Program(program_vec)
    }% 
    |  Program RuleDecl ";" -> {
    let program = &toks[0];
    let extension = toks[1].clone();
    let mut program_vec = match program.item.item {
        Ast::Program(ref v) => v.clone(),
        _ => unreachable!(),
    };
    program_vec.push(extension);
    Ast::Program(program_vec)
    }% 
    |  Alias ";" -> { Ast::Program(toks[..1].to_vec()) }% 
    |  Import ";" -> { Ast::Program(toks[..1].to_vec()) }% 
    |  RuleDecl  ";" -> { Ast::Program(toks[..1].to_vec()) }%;

IdentPath: Ast = IdentPath PathAccess Ident -> {
    let ip = toks[0].clone();
    let extension = toks[2].clone();
    let span = Span::new(ip.item.span.start, extension.item.span.end);
    Ast::IdentPath(span)
}%
    | Ident -> { Ast::IdentPath(toks[0].item.span) }%;

RuleDecl: Ast = IdentPath ":" IdentPath "=" Rule -> {
    let ident = toks[0].item.item.get_src_ref().unwrap();
    let ty = toks[2].item.item.get_src_ref().unwrap();
    let rule_vec = match toks[4].item.item {
        Ast::Rule(ref v) => v.clone(),
        _ => unreachable!(),
    };
    Ast::RuleDecl((ident, ty, rule_vec))
}%;

Rule: Ast = Rule Pipe RulePipe CodeBlock -> {
    let mut rule_vec = match toks[0].item.item {
        Ast::Rule(ref vv) => vv.clone(),
        _ => unreachable!(),
    };
    match toks[2].item.item {
        Ast::RulePipe(ref v) => rule_vec.push((v.clone(), toks[3].item.span)),
        _ => unreachable!(),
    };
    Ast::Rule(rule_vec)
}%
    | RulePipe CodeBlock -> {
    let Ast::RulePipe(ref prod) = toks[0].item.item else {
        unreachable!()
    };
    Ast::Rule(vec![(prod.clone(), toks[1].item.span)])
    }%;

RulePipe: Ast = RulePipe RuleItem -> {
    let mut v = match toks[0].item.item {
        Ast::RulePipe(ref v) => v.clone(),
        _ => unreachable!(),
    };
    v.push(toks[1].clone());
    Ast::RulePipe(v)
}%
    | RuleItem -> {
    Ast::RulePipe(toks[..1].to_vec())
}%;

RuleItem: Ast = IdentPath -> {
    Ast::RuleItem(toks[0].item.span)
}%
    | StrLit -> {
    Ast::RuleItem(toks[0].item.span)
}%;

Import: Ast = "use" IdentPath "::" "*" -> {
    Ast::Import(Span::new(toks[1].item.span.start, toks[3].item.span.end))
}%
    | "use" IdentPath -> {
    Ast::Import(toks[1].item.span)
}%;

Alias: Ast = "alias" Ident IdentPath -> {
    Ast::Alias(toks[1].item.span, toks[2].item.span)
}%
    | AliasWord StrLit IdentPath -> {
    Ast::Alias(toks[1].item.span, toks[2].item.span)
    }%;
